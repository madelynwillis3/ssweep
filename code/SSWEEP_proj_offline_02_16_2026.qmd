---
title: "SSWEEP_proj_02_16_2026"
format: html
---

##### Load libraries

```{r libraries, message=FALSE, warning=FALSE}
#libraries
library(tidyverse)
library(sf)
library(ggplot2)
library(readxl)
library(terra)
library(ranger)
library(viridis)
library(janitor)
library(randomForest)
library(purrr)
library(reshape2)
library(leaflet)
library(scales)
library(htmltools)
library(vegan)
```

##### Load data

```{r load data, message=FALSE, warning=FALSE}
  #load data:
  #new weed ID data (xlsx)
  weed_id_tax <- read_excel("../data/SSWEEP_data_with_tax_and_indices_02_2026.xlsx", sheet = "SSWEEP")
  #indices:
  weed_idx <- read_excel("../data/SSWEEP_data_with_tax_and_indices_02_2026.xlsx", sheet = "Calculations for each grid")

  #Weed ID data (xlsx):
  weed_id <- read_csv("../data/SSWEEP_weed_id_count_data.csv")
    #keep Total sheet but discard other sheets:
    
  #surface sampling (15cm) (.csv):
  surface_sampling <- read_csv("../data/SSWEEP_surface_SP_samples.csv")
  
  #full profile samples:
  # full_profile <- read_csv("../data/SSWEEP_full_profile_samples.csv")
    #covariate stack (.tfs):
     # cov_stack <- rast("../data/covariate_stack_3m.tif")

```

##### Data wrangling: join weed ID data to surface sampling points

```{r data wrangling, message=FALSE, warning=FALSE}
#clean weed_id_tax:
weed_id_tax <- weed_id_tax %>%
  select(1:143) %>%
  #select rows 1:72:
  slice(1:72)

#weed id columns are rows under surface sampling row_num column:
#pivot all columns of weed id:
weed_id_long <- weed_id_tax %>%
  pivot_longer( cols = -c("Common Name","Genus","Species","Family","Life Cycle","Season","Type"),
               names_to = "row_num", 
               values_to = "weed_count") %>%
  #rename ...1 to weed_species 
  rename(weed_species = "Common Name")

#join row_num 
surface_sampling_weed <- surface_sampling %>%
  left_join(weed_id_long, by = "row_num") %>%
  clean_names()

head(surface_sampling_weed)

```

### Map of dominant weed family + dominance share (family abundance / total abundance) at each surface sampling point

###### With circle size scaled by total abundance and fill opacity scaled by dominance share. Use an imagery basemap and a color palette for families. Include legends for both size and opacity.

```{r weed map, warning=FALSE}


# ---- 1) dominant family + dominance share ----
weed_point_family <- surface_sampling_weed %>%
  mutate(
    weed_count = as.numeric(weed_count),
    family = str_squish(family)
  ) %>%
  filter(!is.na(weed_count)) %>%
  group_by(row_num) %>%
  mutate(total_abundance = sum(weed_count, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(row_num, family) %>%
  summarise(
    x = first(x),
    y = first(y),
    total_abundance = first(total_abundance),
    family_abundance = sum(weed_count, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  group_by(row_num) %>%
  slice_max(order_by = family_abundance, n = 1, with_ties = FALSE) %>%
  mutate(dominance = family_abundance / pmax(total_abundance, 1)) %>%
  ungroup()

weed_sf <- st_as_sf(weed_point_family, coords = c("x","y"), crs = 4326)

# ---- 2) palettes + scaling ----
fam_levels <- sort(unique(weed_sf$family))
pal <- colorFactor(palette = "Dark2", domain = fam_levels)   # or "Dark2", "Paired", etc.

# radius from total abundance (cap so one crazy point doesn't take over)
rad <- rescale(weed_sf$total_abundance,
               to = c(4, 18),
               from = c(min(weed_sf$total_abundance, na.rm=TRUE),
                        quantile(weed_sf$total_abundance, 0.95, na.rm=TRUE)))
rad <- pmax(4, rad)

# alpha from dominance (keep visible even if low)
alpha_fill <- pmax(0.25, pmin(1, weed_sf$dominance))

# popup text
popup_txt <- paste0(
  "<b>Grid:</b> ", weed_sf$row_num,
  "<br><b>Dominant family:</b> ", weed_sf$family,
  "<br><b>Total abundance:</b> ", weed_sf$total_abundance,
  "<br><b>Family abundance:</b> ", weed_sf$family_abundance,
  "<br><b>Dominance share:</b> ", round(weed_sf$dominance, 2)
)

# ---- 3) leaflet map with imagery basemap ----
# build an "alpha legend" as HTML
alpha_vals <- round(seq(max(0.25, min(weed_sf$dominance, na.rm=TRUE)),
                        max(weed_sf$dominance, na.rm=TRUE),
                        length.out = 4), 2)

alpha_legend <- tags$div(
  style = "
    background: rgba(255,255,255,0.9);
    padding: 8px 10px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    font-size: 12px;
    line-height: 16px;
  ",
  tags$div(tags$b("Dominance (fill opacity)")),
  tags$div(style="margin-top:6px;",
    lapply(alpha_vals, function(a){
      tags$div(style="display:flex; align-items:center; margin-bottom:4px;",
        # a little circle swatch with different alpha
        tags$span(style = sprintf(
          "display:inline-block; width:12px; height:12px; border-radius:50%%;
           background: rgba(0,0,0,%.2f); border:1px solid #555; margin-right:8px;",
          a
        )),
        tags$span(sprintf("%.2f", a))
      )
    })
  ),
  tags$div(style="margin-top:6px; color:#444;",
           "More opaque = stronger dominance")
)
# ---- SIZE LEGEND (abundance -> circle radius) ----
# pick 4 representative abundance values (min, median, 75th, 95th-ish)
ab_vals <- c(
  min(weed_sf$total_abundance, na.rm = TRUE),
  median(weed_sf$total_abundance, na.rm = TRUE),
  quantile(weed_sf$total_abundance, 0.75, na.rm = TRUE),
  quantile(weed_sf$total_abundance, 0.95, na.rm = TRUE)
) %>% as.numeric() %>% unique() %>% sort()

# convert those abundance values to radii using the SAME mapping you used for points
rad_fun <- function(x) {
  rescale(x, to = c(4, 18),
          from = c(min(weed_sf$total_abundance, na.rm=TRUE),
                   quantile(weed_sf$total_abundance, 0.95, na.rm=TRUE))) %>%
    pmax(4) %>% pmin(18)
}

rad_vals <- rad_fun(ab_vals)

size_legend <- tags$div(
  style = "
    background: rgba(255,255,255,0.9);
    padding: 8px 10px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    font-size: 12px;
    line-height: 16px;
  ",
  tags$div(tags$b("Total abundance (size)")),
  tags$div(style="margin-top:6px;",
    lapply(seq_along(ab_vals), function(i){
      r <- rad_vals[i]
      tags$div(style="display:flex; align-items:center; margin-bottom:6px;",
        # circle swatch sized by radius (diameter = 2r)
        tags$span(style = sprintf(
          "display:inline-block; width:%dpx; height:%dpx; border-radius:50%%;
           background: rgba(0,0,0,0.25); border:1px solid #555; margin-right:10px;",
          round(2*r), round(2*r)
        )),
        tags$span(format(round(ab_vals[i], 1), trim = TRUE))
      )
    })
  )
)

leaflet(weed_sf) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") %>%
  addProviderTiles(providers$CartoDB.Positron, group = "Light") %>%
  addLayersControl(baseGroups = c("Imagery", "Light"),
                   options = layersControlOptions(collapsed = TRUE)) %>%
  addCircleMarkers(
    radius = rad,
    color = ~pal(family),
    weight = 2,
    opacity = 1,
    fillColor = ~pal(family),
    fillOpacity = alpha_fill,
    popup = popup_txt
  ) %>%
  addLegend("bottomright",
            pal = pal,
            values = ~family,
            title = "Dominant family",
            opacity = 1) %>%
  addControl(alpha_legend, position = "bottomleft") %>%
  addControl(size_legend, position = "topleft")

```

```{r}

# re-read sheet 1 cleanly (so we definitely have the bottom rows)
ssweep <- read_excel("../data/SSWEEP_data_with_tax_and_indices_02_2026.xlsx",
                     sheet = "SSWEEP")

# grid columns are like 1A, 22C, 93H, etc.
grid_cols <- names(ssweep)[str_detect(names(ssweep), "^\\d+[A-Za-z]+$")]

# rows at the bottom of sheet 1 that you want
idx_rows <- c(
  "Simpson's diversity index",
  "Shannon Weiner diversity index",
  "Pielou's evenness index",
  "Berger-Parker dominance index"
)

# extract ONLY those index rows + their values across the grid columns
idx_by_point <- ssweep %>%
  filter(`Common Name` %in% idx_rows) %>%
  mutate(idx_name = make_clean_names(`Common Name`)) %>%
  mutate(idx_name = make.unique(idx_name)) %>%   # handles the duplicate Berger-Parker row
  select(idx_name, all_of(grid_cols)) %>%
  pivot_longer(all_of(grid_cols), names_to = "row_num", values_to = "value") %>%
  mutate(value = as.numeric(value)) %>%
  pivot_wider(names_from = idx_name, values_from = value) %>%
  clean_names()

# join onto your surface points (now you have indices per point)
surface_sampling_idx <- surface_sampling %>%
  mutate(row_num = as.character(row_num)) %>%
  left_join(idx_by_point, by = "row_num") %>%
  clean_names()

head(surface_sampling_idx)

```

```{r}
#plot leaflet of shannon index across surface sampling points:
surface_sampling_idx <- surface_sampling_idx %>%
  select(-berger_parker_dominance_index) %>%
  rename(berger_parker_dominance_index = berger_parker_dominance_index_2)

idx_sf <- st_as_sf(surface_sampling_idx, coords = c("x","y"), crs = 4326)

# ---- 1) find all index columns (adjust pattern if needed) ----
idx_cols <- names(idx_sf) %>%
  keep(~ str_detect(.x, "simpson|shannon|pielou|evenness|berger|parker|dominance"))

idx_cols
# (sanity check) if you want to force a specific order:
idx_cols <- idx_cols[idx_cols %in% c(
  "simpsons_diversity_index",
  "shannon_weiner_diversity_index",
  "pielous_evenness_index",
  "berger_parker_dominance_index"
)]

# ---- 2) popup that ALWAYS includes all indices ----
popup_all <- purrr::pmap_chr(
  idx_sf %>% st_drop_geometry() %>% select(row_num, all_of(idx_cols)),
  function(...) {
    r <- list(...)
    rn <- r$row_num
    r$row_num <- NULL

    lines <- purrr::imap_chr(r, \(v, nm) {
      if (is.null(v) || is.na(v)) return(paste0("<b>", nm, ":</b> NA"))
      paste0("<b>", nm, ":</b> ", round(as.numeric(v), 4))
    })

    paste0("<b>Row:</b> ", rn, "<br>", paste(lines, collapse = "<br>"))
  }
)

# Precompute coordinates once
coords <- st_coordinates(idx_sf)

# ---- 3) build leaflet with one overlay per index ----
m <- leaflet(idx_sf) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Imagery") %>%
  addProviderTiles(providers$CartoDB.Positron, group = "Light")

for (col in idx_cols) {
  pal <- colorNumeric("viridis", domain = idx_sf[[col]], na.color = "transparent")

  m <- m %>%
    addCircleMarkers(
      lng = coords[,1], lat = coords[,2],
      radius = 7,
      stroke = TRUE, weight = 1, color = "white",
      fillColor = pal(idx_sf[[col]]),
      fillOpacity = 0.9,
      popup = popup_all,
      group = col
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal,
      values = idx_sf[[col]],
      title = col,
      group = col
    )
}

m %>%
  addLayersControl(
    baseGroups = c("Imagery", "Light"),
    overlayGroups = idx_cols,
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup(idx_cols[-1])  # show first index layer by default
```








### Build training table for RF soil-property rasters

###### Based on surface samples, using covariates extracted at soil sampling points.

```{r RF soil-property rasters, message=FALSE, warning=FALSE}

#questions:
  #can any soil properties predict weed species presence/abundance or diversity indices?
  #what topographic covariates are most predictive of weed species?
  #are there particular soil nutrients that are associated with particular weed species or diversity indices or weed taxa?
  #are there particular disturbance covariates that are associated with particular weed species or diversity indices or weed taxa?
  #are there particular full profile summaries (e.g. root depth) that are associated with particular weed species 
    #or diversity indices or weed taxa?


#plan: pull in disturbance covariate rasters and potentially create rasters such as distance to roads
#pull in other covariates
#potentially pull in full profile data (such as root depth data) to use as predictors in RF soil-property rasters (but only if we have enough points with root depth data to make it worthwhile)
#merge with soil nutrients
#correlation matrix between taxa, nutrients
#correlation matrix between disturbance covariates and weed species and indices
#correlation matrix between full profile summaries and weed species/indicies/nutrients



# Disturbance raster (UTM 17N)
current_dist <- rast("../data/disturbance/currently_dist_binary.tif")

# Recode categorical -> binary (you already did this)
lev <- levels(current_dist)[[1]]
id_col <- names(lev)[1]
yes_id <- lev[[id_col]][lev$CurrentDis == "Yes"]
current_dist_bin <- ifel(current_dist == yes_id, 1, 0)
names(current_dist_bin) <- "dist_current"

# OPTIONAL: distance-to-disturbance raster (meters)
# (distance from each cell to nearest disturbed cell)
dist_to_dist <- distance(current_dist_bin, value = 1)
names(dist_to_dist) <- "dist_to_current_m"

# --- disturbance rasters already made ---
# current_dist_bin (0/1) and dist_to_dist (meters)

# points in raster CRS
soil_pts_ll <- surface_sampling %>%
  select(row_num, x, y, lbc, lbc_eq, p_h_2, ca, k, mg, mn, p, zn) %>%
  st_as_sf(coords = c("x","y"), crs = 4326)

soil_pts_utm <- st_transform(soil_pts_ll, crs(current_dist_bin))

# extract disturbance values
dist_vals <- terra::extract(current_dist_bin, vect(soil_pts_utm)) %>% select(-ID)
dist_dvals <- terra::extract(dist_to_dist, vect(soil_pts_utm)) %>% select(-ID)

soil_dist <- soil_pts_utm %>%
  st_drop_geometry() %>%
  bind_cols(dist_vals, dist_dvals) %>%
  clean_names()




# current_dist_bin is 0/1
# make a target raster: 1 where disturbed, NA elsewhere
target <- ifel(current_dist_bin == 1, 1, NA)

# distance to nearest target cell (meters, since UTM)
dist_to_dist <- distance(target)
names(dist_to_dist) <- "dist_to_current_m"

plot(dist_to_dist)
global(dist_to_dist, "range", na.rm=TRUE)
dist_dvals <- terra::extract(dist_to_dist, vect(soil_pts_utm)) %>% select(-ID)

soil_dist <- soil_pts_utm %>%
  st_drop_geometry() %>%
  bind_cols(dist_vals, dist_dvals) %>%
  janitor::clean_names()

```

```{r}
weed_long <- surface_sampling_weed %>%
  transmute(
    row_num = as.character(row_num),
    family = str_squish(family),
    weed_count = as.numeric(weed_count)
  ) %>%
  filter(!is.na(weed_count))

taxa_point <- weed_long %>%
  group_by(row_num) %>%
  summarise(
    weed_total_abundance = sum(weed_count, na.rm=TRUE),
    weed_species_richness = sum(weed_count > 0, na.rm=TRUE),
    weed_family_richness = n_distinct(family[weed_count > 0]),
    .groups="drop"
  )

dom_family <- weed_long %>%
  group_by(row_num, family) %>%
  summarise(fam_abund = sum(weed_count, na.rm=TRUE), .groups="drop") %>%
  group_by(row_num) %>%
  slice_max(fam_abund, n=1, with_ties=FALSE) %>%
  ungroup() %>%
  left_join(taxa_point, by="row_num") %>%
  mutate(dom_family_share = fam_abund / pmax(weed_total_abundance, 1)) %>%
  select(row_num, dom_family = family, dom_family_abund = fam_abund, dom_family_share,
         weed_total_abundance, weed_species_richness, weed_family_richness)
dat_fast <- soil_dist %>%
  mutate(row_num = as.character(row_num)) %>%
  left_join(dom_family, by="row_num")

glimpse(dat_fast)
soil_vars <- c("lbc","lbc_eq","p_h_2","ca","k","mg","mn","p","zn")

dat_fast %>%
  pivot_longer(all_of(soil_vars), names_to="soil_var", values_to="value") %>%
  ggplot(aes(x = factor(dist_current), y = value)) +
  geom_boxplot(outlier.alpha = 0.3) +
  geom_jitter(width = 0.15, alpha = 0.3) +
  facet_wrap(~ soil_var, scales = "free_y") +
  labs(x = "Currently disturbed (0/1)", y = "Soil value") +
  theme_minimal()
dat_fast %>%
  pivot_longer(all_of(soil_vars), names_to="soil_var", values_to="value") %>%
  ggplot(aes(x = dist_to_current_m, y = value)) +
  geom_point(alpha = 0.35) +
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(~ soil_var, scales = "free_y") +
  labs(x = "Distance to current disturbance (m)", y = "Soil value") +
  theme_minimal()
taxa_vars <- c("weed_total_abundance","weed_species_richness","weed_family_richness","dom_family_share")

dat_fast %>%
  pivot_longer(all_of(taxa_vars), names_to="taxa_var", values_to="value") %>%
  ggplot(aes(x = factor(dist_current), y = value)) +
  geom_boxplot(outlier.alpha = 0.3) +
  geom_jitter(width = 0.15, alpha = 0.3) +
  facet_wrap(~ taxa_var, scales = "free_y") +
  labs(x = "Currently disturbed (No = 0/Yes = 1)", y = "Taxa summary") +
  theme_minimal()
dat_fast %>%
  count(dist_current, dom_family) %>%
  group_by(dist_current) %>%
  mutate(pct = n / sum(n)) %>%
  ggplot(aes(x = factor(dist_current), y = pct, fill = dom_family)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Currently disturbed (No = 0/Yes = 1)", y = "Proportion of points", fill = "Dominant family") +
  theme_minimal()
num_mat <- dat_fast %>%
  select(dist_current, dist_to_current_m, all_of(soil_vars), all_of(taxa_vars)) %>%
  mutate(across(everything(), as.numeric))

cor_small <- cor(num_mat, use="pairwise.complete.obs", method="spearman")
cor_small


```
```{r}
soil_vars <- c("lbc","lbc_eq","p_h_2","ca","k","mg","mn","p","zn")

df_long_soil <- dat_fast %>%
  mutate(dist_current = as.factor(dist_current)) %>%
  pivot_longer(all_of(soil_vars), names_to="soil_var", values_to="value") %>%
  mutate(value = as.numeric(value))

# p-values per facet
p_soil <- df_long_soil %>%
  filter(!is.na(value), !is.na(dist_current)) %>%
  group_by(soil_var) %>%
  summarise(
    n0 = sum(dist_current == "0"),
    n1 = sum(dist_current == "1"),
    p_value = ifelse(n0 >= 2 & n1 >= 2,
      suppressWarnings(wilcox.test(value ~ dist_current)$p.value),
      NA_real_
    ),
    y_pos = max(value, na.rm = TRUE) * 1.05,   # where to print label
    .groups="drop"
  ) %>%
  mutate(
    p_lab = ifelse(is.na(p_value), "p = NA",
                   paste0("Wilcoxon p = ", signif(p_value, 3)))
  )
p_soil <- p_soil %>%
  mutate(p_bh = p.adjust(p_value, method = "BH"),
         p_lab = ifelse(is.na(p_value), "p = NA",
                        paste0("p=", signif(p_value,3),
                               " | BH=", signif(p_bh,3))))

ggplot(df_long_soil, aes(x = dist_current, y = value)) +
  geom_boxplot(outlier.alpha = 0.3) +
  geom_jitter(width = 0.15, alpha = 0.3) +
  facet_wrap(~ soil_var, scales = "free_y") +
  geom_text(
    data = p_soil,
    aes(x = 1.5, y = y_pos, label = p_lab),
    inherit.aes = FALSE,
    size = 3
  ) +
  labs(x = "Currently disturbed (0/1)", y = "Soil value") +
  theme_minimal()

taxa_vars <- c("weed_total_abundance","weed_species_richness",
               "weed_family_richness","dom_family_share")

df_long_taxa <- dat_fast %>%
  mutate(dist_current = as.factor(dist_current)) %>%
  pivot_longer(all_of(taxa_vars), names_to="taxa_var", values_to="value") %>%
  mutate(value = as.numeric(value))

p_taxa <- df_long_taxa %>%
  filter(!is.na(value), !is.na(dist_current)) %>%
  group_by(taxa_var) %>%
  summarise(
    n0 = sum(dist_current == "0"),
    n1 = sum(dist_current == "1"),
    p_value = ifelse(n0 >= 2 & n1 >= 2,
      suppressWarnings(wilcox.test(value ~ dist_current)$p.value),
      NA_real_
    ),
    y_pos = max(value, na.rm = TRUE) * 1.05,
    .groups="drop"
  ) %>%
  mutate(p_lab = ifelse(is.na(p_value), "p = NA",
                        paste0("Wilcoxon p = ", signif(p_value, 3))))

ggplot(df_long_taxa, aes(x = dist_current, y = value)) +
  geom_boxplot(outlier.alpha = 0.3) +
  geom_jitter(width = 0.15, alpha = 0.3) +
  facet_wrap(~ taxa_var, scales = "free_y") +
  geom_text(
    data = p_taxa,
    aes(x = 1.5, y = y_pos, label = p_lab),
    inherit.aes = FALSE,
    size = 3
  ) +
  labs(x = "Currently disturbed (0/1)", y = "Taxa summary") +
  theme_minimal()
## counts of dominant family by disturbance
tab <- dat_fast %>%
  filter(!is.na(dom_family), dom_family != "") %>%
  count(dist_current, dom_family) %>%
  tidyr::pivot_wider(names_from = dist_current, values_from = n, values_fill = 0)

mat <- as.matrix(tab[, -1])
rownames(mat) <- tab$dom_family

# Fisher (robust for small counts)
fisher.test(mat)

# If counts are all decent, chi-square is fine:
chisq.test(mat)   # watch for the "approximation may be incorrect" warning

# family abundance per point
fam_point <- surface_sampling_weed %>%
  transmute(
    row_num = as.character(row_num),
    family  = str_squish(family),
    weed_count = as.numeric(weed_count)
  ) %>%
  filter(!is.na(family), family != "", !is.na(weed_count)) %>%
  group_by(row_num, family) %>%
  summarise(fam_abund = sum(weed_count, na.rm = TRUE), .groups="drop")

# join disturbance
fam_dist <- soil_dist %>%
  transmute(row_num = as.character(row_num),
            dist_current = as.factor(dist_current)) %>%
  left_join(fam_point, by = "row_num") %>%
  mutate(fam_abund = replace_na(fam_abund, 0))

# optional: keep only families present in >= N points (otherwise p-values are junk)
min_pts <- 10
keep_fam <- fam_dist %>%
  group_by(family) %>%
  summarise(n_pts = sum(fam_abund > 0), .groups="drop") %>%
  filter(n_pts >= min_pts) %>%
  pull(family)

fam_dist2 <- fam_dist %>% filter(family %in% keep_fam)

# p-values per family (Wilcoxon)
p_fam <- fam_dist2 %>%
  group_by(family) %>%
  summarise(
    n0 = sum(dist_current == "0"),
    n1 = sum(dist_current == "1"),
    p_value = ifelse(n0 >= 2 & n1 >= 2,
                     suppressWarnings(wilcox.test(fam_abund ~ dist_current)$p.value),
                     NA_real_),
    y_pos = max(fam_abund, na.rm=TRUE) * 1.05,
    .groups="drop"
  ) %>%
  mutate(
    p_bh = p.adjust(p_value, method = "BH"),  # optional
    p_lab = ifelse(is.na(p_value), "p=NA",
                   paste0("p=", signif(p_value,3),
                          " | BH=", signif(p_bh,3)))
  )

ggplot(fam_dist2, aes(x = dist_current, y = fam_abund)) +
  geom_boxplot(outlier.alpha = 0.3) +
  geom_jitter(width = 0.15, alpha = 0.25) +
  facet_wrap(~ family, scales = "free_y") +
  geom_text(data = p_fam,
            aes(x = 1.5, y = y_pos, label = p_lab),
            inherit.aes = FALSE, size = 3) +
  labs(x = "Currently disturbed (0/1)", y = "Family abundance") +
  theme_minimal()



# 1) family abundance per point
fam_point <- surface_sampling_weed %>%
  transmute(
    row_num = as.character(row_num),
    family  = str_squish(family),
    weed_count = as.numeric(weed_count)
  ) %>%
  filter(!is.na(family), family != "", !is.na(weed_count)) %>%
  group_by(row_num, family) %>%
  summarise(fam_abund = sum(weed_count, na.rm = TRUE), .groups = "drop")

# 2) join distance to disturbance
fam_dist <- dat_fast %>%
  transmute(
    row_num = as.character(row_num),
    dist_to_current_m = as.numeric(dist_to_current_m)
  ) %>%
  left_join(fam_point, by = "row_num") %>%
  mutate(fam_abund = replace_na(fam_abund, 0)) %>%
  filter(!is.na(dist_to_current_m))

# 3) (recommended) keep only families present in enough points
min_pts <- 10
keep_fam <- fam_dist %>%
  group_by(family) %>%
  summarise(n_pts = sum(fam_abund > 0), .groups="drop") %>%
  filter(n_pts >= min_pts) %>%
  pull(family)

fam_dist2 <- fam_dist %>% filter(family %in% keep_fam)

# 4) plot
ggplot(fam_dist2, aes(x = dist_to_current_m, y = fam_abund)) +
  geom_point(alpha = 0.35) +
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(~ family, scales = "free_y") +
  labs(x = "Distance to current disturbance (m)", y = "Family abundance") +
  theme_minimal()

```



```{r}

tab <- dat_fast %>%
  filter(!is.na(dom_family)) %>%
  count(dist_current, dom_family) %>%
  pivot_wider(names_from = dist_current, values_from = n, values_fill = 0)

# dominant family x disturbance (0/1)
mat <- dat_fast %>%
  filter(!is.na(dom_family), !is.na(dist_current)) %>%
  count(dom_family, dist_current) %>%
  tidyr::pivot_wider(names_from = dist_current, values_from = n, values_fill = 0) %>%
  tibble::column_to_rownames("dom_family") %>%
  as.matrix()

dim(mat)
mat[1:5, , drop = FALSE]

chisq <- chisq.test(mat)

chisq$p.value
chisq$expected[1:5, , drop = FALSE]   # peek at expected counts

# standardized residuals (always coerce to matrix)
resid_mat <- as.matrix(chisq$stdres)

# top contributors (big absolute residuals)
top_resid <- as.data.frame(as.table(resid_mat)) %>%
  mutate(abs_resid = abs(Freq)) %>%
  arrange(desc(abs_resid))

head(top_resid, 15)
chisq_mc <- chisq.test(mat, simulate.p.value = TRUE, B = 9999)
chisq_mc$p.value
min_n <- 3  # threshold for rare dominant families

dat_dom <- dat_fast %>%
  filter(!is.na(dom_family), !is.na(dist_current)) %>%
  group_by(dom_family) %>%
  mutate(tot = n()) %>%
  ungroup() %>%
  mutate(dom_family2 = if_else(tot < min_n, "Other", dom_family))

mat2 <- dat_dom %>%
  count(dom_family2, dist_current) %>%
  pivot_wider(names_from = dist_current, values_from = n, values_fill = 0) %>%
  tibble::column_to_rownames("dom_family2") %>%
  as.matrix()

chisq2 <- chisq.test(mat2)
chisq2$p.value

# long weed table with counts
weed_long <- surface_sampling_weed %>%
  transmute(
    row_num = as.character(row_num),
    family = str_squish(family),
    weed_count = as.numeric(weed_count)
  ) %>%
  filter(!is.na(weed_count), !is.na(family))

# point x family abundance
fam_wide <- weed_long %>%
  group_by(row_num, family) %>%
  summarise(abund = sum(weed_count, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = family, values_from = abund, values_fill = 0)

# community matrix (rows = points, cols = families)
comm <- fam_wide %>%
  column_to_rownames("row_num") %>%
  as.matrix()

# remove points with zero total weeds (Bray-Curtis doesn't like all-zero rows)
keep_rows <- rowSums(comm) > 0
comm <- comm[keep_rows, , drop = FALSE]

# convert to relative abundance (recommended)
comm_rel <- decostand(comm, method = "total")
meta <- soil_dist %>%
  transmute(
    row_num = as.character(row_num),
    dist_current = factor(dist_current),          # 0/1 as factor for grouping
    dist_to_current_m = as.numeric(dist_to_current_m)
  ) %>%
  filter(row_num %in% rownames(comm_rel)) %>%
  distinct(row_num, .keep_all = TRUE) %>%
  arrange(match(row_num, rownames(comm_rel)))

# align rows exactly (important!)
comm_rel <- comm_rel[meta$row_num, , drop = FALSE]
stopifnot(all(meta$row_num == rownames(comm_rel)))
set.seed(1)
adon_bin <- adonis2(comm_rel ~ dist_current, data = meta, method = "bray", permutations = 9999)
adon_bin
set.seed(1)
adon_dist <- adonis2(comm_rel ~ dist_to_current_m, data = meta, method = "bray", permutations = 9999)
adon_dist
set.seed(1)
adon_both <- adonis2(comm_rel ~ dist_current + dist_to_current_m, data = meta, method = "bray", permutations = 9999)
adon_both
bray <- vegdist(comm_rel, method = "bray")

bd <- betadisper(bray, meta$dist_current)
anova(bd)           # test of dispersion differences
permutest(bd, permutations = 9999)

# quick visualization
plot(bd)
boxplot(bd, ylab = "Distance to group centroid (Bray-Curtis)")
ord <- metaMDS(comm_rel, distance = "bray", k = 2, trymax = 50)

plot(ord, type = "n")
points(ord, display = "sites",
       pch = 19,
       col = ifelse(meta$dist_current == 1, "red", "blue"))
legend("topright", legend = c("Not disturbed (0)", "Disturbed (1)"),
       col = c("blue", "red"), pch = 19, bty = "n")


# for a more focused test, subset to just the undisturbed points and see if distance to disturbance still matters
meta2 <- meta %>% filter(dist_current == 0)
comm2 <- comm_rel[meta2$row_num, , drop = FALSE]

set.seed(1)
adon_outside <- adonis2(comm2 ~ dist_to_current_m, data = meta2, method="bray", permutations=9999)
adon_outside 
# even among undisturbed points, distance to disturbance has a significant effect on community composition (p = 0.0038)
# “Distance to disturbance remained a significant predictor of weed family composition even when analyses were restricted to undisturbed sampling points (PERMANOVA, Bray–Curtis, R² = 0.0277, p = 0.0038), indicating that compositional differences extend beyond disturbance polygons and are consistent with a proximity (edge) effect.”
```


```{r}
set.seed(1234)
soil_vars <- c("lbc","lbc_eq","p_h_2","ca","k","mg","mn","p","zn")

# long weeds (you already have surface_sampling_weed)
weed_long2 <- surface_sampling_weed %>%
  transmute(
    row_num = as.character(row_num),
    family  = str_squish(family),
    genus   = str_squish(genus),
    weed_count = as.numeric(weed_count)
  ) %>%
  filter(!is.na(weed_count))

# point-level soil table
soil_point <- surface_sampling %>%
  transmute(row_num = as.character(row_num),
            across(all_of(soil_vars), as.numeric))

# family abundance per point
fam_y <- weed_long2 %>%
  group_by(row_num, family) %>%
  summarise(y = sum(weed_count, na.rm = TRUE), .groups="drop") %>%
  filter(!is.na(family), family != "")

# genus abundance per point
gen_y <- weed_long2 %>%
  group_by(row_num, genus) %>%
  summarise(y = sum(weed_count, na.rm = TRUE), .groups="drop") %>%
  filter(!is.na(genus), genus != "")
min_points <- 10   # only model taxa present in >=10 points
num_trees  <- 500  # bump to 1000 later if you want

fit_rf_by_taxon <- function(y_tbl, taxon_col, soil_df) {
  taxon_sym <- rlang::sym(taxon_col)

  eligible <- y_tbl %>%
    group_by(!!taxon_sym) %>%
    summarise(n_pts = sum(y > 0), .groups="drop") %>%
    filter(n_pts >= min_points) %>%
    pull(!!taxon_sym)

  y_tbl %>%
    filter((!!taxon_sym) %in% eligible) %>%
    group_split(!!taxon_sym) %>%
    purrr::map(function(d) {
      taxon_name <- d[[taxon_col]][1]

      dat <- soil_df %>%
        left_join(d %>% select(row_num, y), by = "row_num") %>%
        mutate(y = replace_na(y, 0))

      # ranger regression RF
      mod <- ranger::ranger(
        y ~ .,
        data = dat %>% select(-row_num),
        num.trees = num_trees,
        importance = "permutation",
        respect.unordered.factors = "order",
        seed = 1
      )

      imp <- mod$variable.importance

      tibble(
        taxon = taxon_name,
        soil_variable = names(imp),
        importance = as.numeric(imp)
      )
    }) %>%
    bind_rows()
}

varimp_family <- fit_rf_by_taxon(fam_y, "family", soil_point)
varimp_genus  <- fit_rf_by_taxon(gen_y, "genus",  soil_point)
soil_labels <- c(
  lbc    = "LBC ",
  lbc_eq = "LBCeq ",
  p_h_2  = "pH",
  ca     = "Ca ",
  k      = "K ",
  mg     = "Mg ",
  mn     = "Mn ",
  p      = "P ",
  zn     = "Zn "
)

soil_vars <- names(soil_labels)  # keeps order

plot_varimp_heat_raw <- function(varimp_df, title_txt, digits = 3) {

  dfp <- varimp_df %>%
    mutate(
      soil_variable = factor(soil_variable, levels = soil_vars),
      soil_label    = factor(soil_labels[as.character(soil_variable)], levels = soil_labels),
      label = if_else(is.na(importance), "", format(round(importance, digits), nsmall = digits)),
      label_col = if_else(!is.na(importance) & importance < 35, "white", "black")
    ) %>%
    group_by(taxon) %>%
    mutate(taxon_mean = mean(abs(importance), na.rm = TRUE)) %>%  # order by overall signal
    ungroup() %>%
    mutate(taxon = reorder(taxon, taxon_mean))

  ggplot(dfp, aes(x = soil_label, y = taxon, fill = importance)) +
    geom_tile(color = "white") +
    geom_text(aes(label = label, color = label_col), size = 2.8) +
    scale_color_identity() +
    scale_fill_viridis_c(option = "magma", name = "Permutation\nimportance") +
    labs(
      title = title_txt,
      subtitle = "Raw (signed) permutation importance from ranger (all cells labeled).",
      x = "Surface soil property",
      y = NULL
    ) +
    theme_minimal(base_size = 10) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold")
    )
}

p_fam_raw <- plot_varimp_heat_raw(varimp_family, "Soil drivers of weed FAMILY abundance (raw importance)", digits = 3)
p_gen_raw <- plot_varimp_heat_raw(varimp_genus,  "Soil drivers of weed GENUS abundance (raw importance)",  digits = 3)

p_fam_raw
p_gen_raw


```
```{r spearman correlation plot, message=FALSE, warning=FALSE, eval = FALSE}

make_taxon_soil_corplot <- function(surface_sampling_weed, surface_sampling,
                                    taxon_col = c("genus","family"),
                                    title_txt = NULL,
                                    min_pts = 8,
                                    digits = 2) {

  taxon_col <- match.arg(taxon_col)

  # 1) point-level taxon abundance wide
  tax_wide <- surface_sampling_weed %>%
    transmute(
      row_num = as.character(row_num),
      taxon = str_squish(.data[[taxon_col]]),
      weed_count = as.numeric(weed_count)
    ) %>%
    filter(!is.na(taxon), taxon != "", !is.na(weed_count)) %>%
    group_by(row_num, taxon) %>%
    summarise(abund = sum(weed_count, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = taxon, values_from = abund, values_fill = 0)

  # 2) soil table
  soil_point <- surface_sampling %>%
    transmute(row_num = as.character(row_num),
              across(all_of(soil_vars), as.numeric))

  dat <- soil_point %>%
    inner_join(tax_wide, by = "row_num")

  taxon_cols <- setdiff(names(dat), c("row_num", soil_vars))

  # 3) restrict to taxa present in >= min_pts points
  n_pts <- dat %>%
    summarise(across(all_of(taxon_cols), ~sum(.x > 0, na.rm = TRUE))) %>%
    pivot_longer(everything(), names_to = "taxon", values_to = "n_pts")

  keep_taxa <- n_pts %>%
    filter(n_pts >= min_pts) %>%
    pull(taxon)

  if (length(keep_taxa) == 0) stop("No taxa meet min_pts threshold. Lower min_pts.")

  # 4) compute Spearman rho for each (taxon, soil_var)
  cor_long <- expand_grid(taxon = keep_taxa, soil_variable = soil_vars) %>%
    rowwise() %>%
    mutate(
      rho = suppressWarnings(
        cor(dat[[taxon]], dat[[soil_variable]],
            method = "spearman", use = "pairwise.complete.obs")
      )
    ) %>%
    ungroup()

  # 5) sort taxa by mean absolute correlation strength (highest -> lowest)
  tax_order <- cor_long %>%
    group_by(taxon) %>%
    summarise(mean_abs_rho = mean(abs(rho), na.rm = TRUE), .groups = "drop") %>%
    arrange(desc(mean_abs_rho)) %>%
    pull(taxon)

  # 6) set color limits to observed min/max rho (after filtering)
  lims <- range(cor_long$rho, na.rm = TRUE)

  # 7) plot
  if (is.null(title_txt)) {
    title_txt <- paste0(str_to_title(taxon_col), " abundance vs soil nutrients")
  }

  cor_long %>%
  mutate(
  soil_label = factor(soil_labels[soil_variable], levels = soil_labels),
  taxon = factor(taxon, levels = tax_order),
  label = if_else(is.na(rho), "", sprintf(paste0("%.", digits, "f"), rho)),
  label_col = if_else(!is.na(rho) & rho < 0, "white", "black"))%>%
ggplot(aes(x = soil_label, y = taxon, fill = rho)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label, color = label_col), size = 2.8) +
  scale_color_identity() +
  scale_fill_viridis_c(option = "magma", name = "Spearman\nρ", limits = lims) +
    labs(
      title = title_txt,
      subtitle = paste0(
        "Filtered to taxa present in ≥", min_pts, " points. ",
        "Color scale set to observed min/max ρ."
      ),
      x = "Surface soil property",
      y = str_to_title(taxon_col)
    ) +
    theme_minimal(base_size = 10) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold")
    )
}

p_cor_gen <- make_taxon_soil_corplot(
  surface_sampling_weed = surface_sampling_weed,
  surface_sampling      = surface_sampling,
  taxon_col = "genus",
  title_txt = "Genus abundance vs soil nutrients (Spearman ρ)",
  min_pts = 8,
  digits = 2
)
p_cor_gen
p_cor_fam <- make_taxon_soil_corplot(
  surface_sampling_weed = surface_sampling_weed,
  surface_sampling      = surface_sampling,
  taxon_col = "family",
  title_txt = "Family abundance vs soil nutrients (Spearman ρ)",
  min_pts = 8,
  digits = 2
)
p_cor_fam



```
```{r FDR correction, message=FALSE, warning=FALSE, eval = FALSE}
#FDR correction:
make_taxon_soil_corplot_fdr <- function(surface_sampling_weed, surface_sampling,
                                        soil_vars, soil_labels,
                                        taxon_col = c("genus","family"),
                                        min_pts = 8,
                                        digits = 2,
                                        alpha = 0.10,
                                        show = c("fdr_star","fdr_only","all")) {

  show <- match.arg(show)
  taxon_col <- match.arg(taxon_col)

  # 1) point-level taxon abundance wide
  tax_wide <- surface_sampling_weed %>%
    transmute(
      row_num = stringr::str_squish(as.character(row_num)),
      taxon   = stringr::str_squish(.data[[taxon_col]]),
      weed_count = readr::parse_number(as.character(weed_count))
    ) %>%
    filter(!is.na(taxon), taxon != "", !is.na(weed_count)) %>%
    group_by(row_num, taxon) %>%
    summarise(abund = sum(weed_count, na.rm = TRUE), .groups = "drop") %>%
    tidyr::pivot_wider(names_from = taxon, values_from = abund, values_fill = 0)

  # 2) soil table
  soil_point <- surface_sampling %>%
    transmute(
      row_num = stringr::str_squish(as.character(row_num)),
      across(all_of(soil_vars), ~ readr::parse_number(as.character(.x)))
    )

  dat <- dplyr::inner_join(soil_point, tax_wide, by = "row_num")
  if (nrow(dat) == 0) stop("Join produced 0 rows. Check row_num formatting.")

  taxon_cols <- setdiff(names(dat), c("row_num", soil_vars))

  # keep taxa present in >= min_pts points
  keep_taxa <- dat %>%
    summarise(across(all_of(taxon_cols), ~sum(.x > 0, na.rm = TRUE))) %>%
    pivot_longer(everything(), names_to = "taxon", values_to = "n_pts") %>%
    filter(n_pts >= min_pts) %>%
    pull(taxon)

  if (length(keep_taxa) == 0) stop("No taxa meet min_pts threshold. Lower min_pts.")

  # Spearman-safe helper
  safe_spearman <- function(x, y) {
    ok <- is.finite(x) & is.finite(y)
    x <- x[ok]; y <- y[ok]
    if (length(x) < 3) return(c(rho = NA_real_, p = NA_real_))
    if (length(unique(x)) < 2 || length(unique(y)) < 2) return(c(rho = NA_real_, p = NA_real_))
    ct <- suppressWarnings(stats::cor.test(x, y, method = "spearman", exact = FALSE))
    c(rho = unname(ct$estimate), p = ct$p.value)
  }

  # compute rho + p
  cor_long <- tidyr::expand_grid(taxon = keep_taxa, soil_variable = soil_vars) %>%
    rowwise() %>%
    mutate(
      tmp = list(safe_spearman(dat[[taxon]], dat[[soil_variable]])),
      rho = tmp[[1]]["rho"],
      p   = tmp[[1]]["p"]
    ) %>%
    ungroup() %>%
    mutate(
      p_fdr  = p.adjust(p, method = "BH"),
      sig_fdr = !is.na(p_fdr) & p_fdr < alpha
    )

  # order taxa by mean |rho|
  tax_order <- cor_long %>%
    group_by(taxon) %>%
    summarise(mean_abs_rho = mean(abs(rho), na.rm = TRUE), .groups = "drop") %>%
    arrange(desc(mean_abs_rho)) %>%
    pull(taxon)

  # color limits to observed min/max rho (ignore NA)
  lims <- range(cor_long$rho, na.rm = TRUE)

  # build plot table
  plot_df <- cor_long %>%
    mutate(
      soil_label = factor(soil_labels[soil_variable], levels = soil_labels),
      taxon      = factor(taxon, levels = tax_order),
      lab = if_else(is.na(rho), "", sprintf(paste0("%.", digits, "f"), rho)),
      lab = if (show == "fdr_star") if_else(sig_fdr, paste0(lab, "*"), lab) else lab,
      lab = if (show == "fdr_only") if_else(sig_fdr, lab, "") else lab,
      label_col = if_else(!is.na(rho) & rho < 0, "white", "black")
    )

  p <- ggplot(plot_df, aes(x = soil_label, y = taxon, fill = rho)) +
    geom_tile(color = "white") +
    geom_text(aes(label = lab, color = label_col), size = 2.8) +
    scale_color_identity() +
    scale_fill_viridis_c(option = "magma", name = "Spearman\nρ", limits = lims) +
    labs(
      title = paste0(stringr::str_to_title(taxon_col), " abundance vs soil nutrients (Spearman ρ)"),
      subtitle = paste0(
        "FDR (BH) α=", alpha, ". Filtered to taxa present in ≥", min_pts, " points. ",
        if (show == "fdr_star") "* = FDR-significant." else if (show == "fdr_only") "Labels shown only if FDR-significant." else ""
      ),
      x = "Surface soil property",
      y = stringr::str_to_title(taxon_col)
    ) +
    theme_minimal(base_size = 10) +
    theme(
      panel.grid = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold")
    )

  list(plot = p, table = cor_long)
}
res_gen <- make_taxon_soil_corplot_fdr(surface_sampling_weed, surface_sampling,
                                      soil_vars, soil_labels,
                                      taxon_col="genus", min_pts=8, alpha=0.05, show="fdr_star")
res_gen$plot

res_fam <- make_taxon_soil_corplot_fdr(surface_sampling_weed, surface_sampling,
                                      soil_vars, soil_labels,
                                      taxon_col="family", min_pts=8, alpha=0.05, show="fdr_star")
res_fam$plot

#“no associations survived FDR at 0.05; patterns interpreted descriptively.”

```





```{r correlation matrix, message=FALSE, warning=FALSE, eval=FALSE}

# pick the index columns you actually want
idx_cols <- c(
  "simpsons_diversity_index",
  "shannon_weiner_diversity_index",
  "pielous_evenness_index",
  "berger_parker_dominance_index"
)

dist_cols <- c("dist_current", "dist_to_current_m")

dat_idx <- soil_dist %>%
  mutate(row_num = as.character(row_num)) %>%
  select(row_num, any_of(dist_cols)) %>%
  left_join(
    surface_sampling_idx %>%
      mutate(row_num = as.character(row_num)) %>%
      select(row_num, any_of(idx_cols)),
    by = "row_num"
  ) %>%
  mutate(across(all_of(c(dist_cols, idx_cols)), ~ suppressWarnings(as.numeric(.x))))
cor_mat <- cor(
  dat_idx %>% select(all_of(c(dist_cols, idx_cols))),
  use = "pairwise.complete.obs",
  method = "spearman"
)

cor_mat
cor_block <- cor_mat[dist_cols, idx_cols, drop = FALSE]
cor_block
library(corrplot)
corrplot::corrplot(cor_block, is.corr = TRUE, method = "color",
                   tl.cex = 0.9, mar = c(0,0,1,0))

```

